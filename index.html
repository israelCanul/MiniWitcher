<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <title>Monster Hunter: Hub Worlds</title>
    <style>
        html,
        body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #050505;
            font-family: 'Courier New', monospace;
            user-select: none;
        }

        #game-container {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            outline: none;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            display: none;
        }

        .hud-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 280px;
            background: rgba(20, 15, 10, 0.9);
            padding: 15px;
            border: 2px solid #8d6e63;
            border-radius: 4px;
            color: #eee;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.8);
        }

        .bar {
            height: 10px;
            background: #333;
            margin-bottom: 8px;
            border-radius: 2px;
            overflow: hidden;
        }

        .fill {
            height: 100%;
            transition: width 0.2s ease-out;
        }

        .biome-title {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            font-size: 2em;
            color: #fff;
            text-shadow: 0 0 10px #000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 2s;
        }

        .controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: #aaa;
            font-size: 12px;
            text-shadow: 1px 1px 2px black;
            font-weight: bold;
        }

        #minimap-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 150px;
            height: 150px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #5d4037;
            border-radius: 4px;
            overflow: hidden;
        }

        #minimap {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* PANTALLAS */
        .screen-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0a0a0a;
            color: #ffa726;
            z-index: 2000;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: default;
            flex-direction: column;
            transition: opacity 0.5s;
        }

        #loading-bar {
            width: 300px;
            height: 4px;
            background: #333;
            margin-top: 20px;
            border-radius: 2px;
        }

        #loading-progress {
            width: 0%;
            height: 100%;
            background: #ffa726;
            transition: width 0.2s;
        }

        #death-screen {
            display: none;
            background: rgba(50, 0, 0, 0.9);
            z-index: 3000;
        }

        .btn {
            margin-top: 20px;
            padding: 10px 30px;
            font-size: 1.2em;
            background: #ffa726;
            border: none;
            color: #000;
            font-weight: bold;
            cursor: pointer;
        }

        .btn:hover {
            background: #ffcc80;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>

<body>

    <div id="game-container" tabindex="0"></div>

    <!-- PANTALLA DE CARGA -->
    <div id="loading-screen" class="screen-overlay" onclick="startGame()">
        <h1 style="font-size:3.5em; margin:0;">MONSTER HUNTER</h1>
        <p>HUB WORLDS</p>
        <div id="loading-bar">
            <div id="loading-progress"></div>
        </div>
        <p id="loading-text" style="font-size:0.8em; color:#888; margin-top:10px;">Sistema listo.</p>
        <button class="btn" onclick="startGame()" style="margin-top:20px;">INICIAR AVENTURA</button>
    </div>

    <!-- PANTALLA DE MUERTE -->
    <div id="death-screen" class="screen-overlay">
        <h1 style="font-size:4em; color: #e53935;">HAS MUERTO</h1>
        <p>Tu viaje ha terminado... por ahora.</p>
        <button class="btn" onclick="respawnPlayer()">RENACER EN EL BOSQUE</button>
    </div>

    <!-- UI JUEGO -->
    <div id="ui-layer">
        <div class="biome-title" id="biome-label">BOSQUE CENTRAL</div>

        <div class="hud-panel">
            <strong>HP</strong>
            <div class="bar">
                <div id="hp-bar" class="fill" style="background:#d32f2f; width:100%"></div>
            </div>
            <strong>VIGOR</strong>
            <div class="bar">
                <div id="stam-bar" class="fill" style="background:#fbc02d; width:100%"></div>
            </div>
            <div id="quest-text"
                style="color:#ffcc80; margin-top:10px; border-top:1px solid #5d4037; padding-top:5px; font-size: 0.9em;">
                Usa los portales rojos para viajar
            </div>
        </div>

        <div id="minimap-container">
            <canvas id="minimap" width="150" height="150"></canvas>
        </div>

        <div class="controls">[W,A,S,D] MOVER • [MOUSE] ATACAR</div>
    </div>

    <script>
        // 1. VARIABLES GLOBALES
        var SCENARIO_SIZE = 200;
        var TILE_SIZE = 2;

        var scene, camera, renderer, clock, player;
        var enemies = [], guards = [], citizens = [], particles = [], solidColliders = [];
        var worldGroup;
        var mapCtx, mapCanvas;
        var isRunning = false;

        var currentBiomeCoords = { x: 0, y: 0 };
        var swampCaves = [];
        var villageCenters = [];
        var activePortals = [];

        var keys = { w: 0, a: 0, s: 0, d: 0 };
        var mouse = new THREE.Vector2();
        var raycaster = new THREE.Raycaster();
        var mousePlane;

        // Datos de Biomas
        var BIOME_DATA = {
            '0,0': { name: "Bosque Central (Hub)", type: 'forest', color: 0x2e7d32, sky: 0x87ceeb },
            '0,-1': { name: "Tundra del Norte", type: 'snow', color: 0xe3f2fd, sky: 0xb0bec5 },
            '0,1': { name: "Pantano del Sur", type: 'swamp', color: 0x33691e, sky: 0x455a64 },
            '1,0': { name: "Desierto del Este", type: 'desert', color: 0xffcc80, sky: 0xffe0b2 },
            '-1,0': { name: "Selva del Oeste", type: 'jungle', color: 0x1b5e20, sky: 0x004d40 }
        };

        var PALETTE = {
            grass: 0x4caf50, dirt: 0x795548, water: 0x29b6f6,
            snow: 0xffffff, ice: 0x81d4fa,
            sand: 0xffcc80, cactus: 0x66bb6a,
            swampGrass: 0x33691e, swampWater: 0x1b5e20, swampDirt: 0x2e3b20,
            jungleGrass: 0x00695c,
            rock: 0x757575, rockSnow: 0xeeeeee,
            wood: 0x5d4037, leaves: 0x2e7d32,
            pineWood: 0x3e2723, pineLeaves: 0x1b5e20,
            deadWood: 0x4e342e, weed: 0x558b2f,
            crop: 0x8d6e63, cropPlant: 0x66bb6a,
            skin: 0xffcc80, armor: 0x37474f, hair: 0xeeeeee,
            banditSkin: 0xd7ccc8, banditLeather: 0x4e342e, banditPants: 0x212121,
            soldierArmor: 0x90a4ae, soldierDetail: 0x1565c0,
            werewolfFur: 0x3e2723, werewolfSkin: 0x4e342e,
            crocSkin: 0x2e7d32, crocDetail: 0x81c784,
            plantStem: 0x33691e, plantHead: 0xb71c1c,
            flowers: [0xffeb3b, 0xf44336, 0x2196f3, 0xff9800],
            civShirts: [0x795548, 0x5d4037, 0x8d6e63, 0xffcc80, 0xffab91, 0xa1887f],
            civPants: [0x3e2723, 0x4e342e, 0x263238, 0x212121]
        };

        // --- 2. FUNCIONES DE UTILIDAD ---
        window.handleKey = function (e, val) {
            if (e.key === 'w' || e.code === 'ArrowUp') keys.w = val;
            if (e.key === 's' || e.code === 'ArrowDown') keys.s = val;
            if (e.key === 'a' || e.code === 'ArrowLeft') keys.a = val;
            if (e.key === 'd' || e.code === 'ArrowRight') keys.d = val;
        };

        window.onResize = function () {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };

        window.startGame = function () {
            if (isRunning) return;
            document.getElementById('loading-screen').style.display = 'none';
            document.getElementById('ui-layer').style.display = 'block';
            mapCanvas = document.getElementById('minimap');
            mapCtx = mapCanvas.getContext('2d');
            document.getElementById('game-container').focus();

            init(); // Ahora init está definido abajo
            loadBiome(0, 0);
            isRunning = true;
            animate();
        };

        window.respawnPlayer = function () {
            player.hp = 100;
            player.mesh.position.set(0, 0, 0);
            loadBiome(0, 0);
            document.getElementById('death-screen').style.display = 'none';
            isRunning = true;
            animate();
        };

        function addCollider(x, z, size) {
            if (Math.abs(x) < 2 && Math.abs(z) < 2) return;
            const box = new THREE.Box3();
            box.setFromCenterAndSize(new THREE.Vector3(x, 2, z), new THREE.Vector3(size * 0.8, 10, size * 0.8));
            solidColliders.push(box);
        }

        function createCube(w, h, d, c, x, y, z) {
            const m = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), new THREE.MeshStandardMaterial({ color: c }));
            m.position.set(x, y, z); m.castShadow = true; return m;
        }

        function getVillageColors(type) {
            const styles = [
                { wall: 0x8d6e63, roof: 0xd84315 }, { wall: 0x90a4ae, roof: 0x37474f },
                { wall: 0xffcc80, roof: 0xe65100 }, { wall: 0x558b2f, roof: 0x33691e }, { wall: 0xeeeeee, roof: 0x212121 }
            ];
            return styles[type % styles.length];
        }

        function createFloatText(pos, txt) {
            const d = document.createElement('div'); d.innerText = txt; d.style.position = 'absolute'; d.style.color = 'red'; d.style.fontWeight = 'bold'; document.body.appendChild(d);
            const p = pos.clone(); p.y += 2; p.project(camera);
            d.style.left = (p.x * .5 + .5) * window.innerWidth + 'px'; d.style.top = (-(p.y * .5) + .5) * window.innerHeight + 'px';
            d.animate([{ transform: 'translateY(0)', opacity: 1 }, { transform: 'translateY(-30px)', opacity: 0 }], 500); setTimeout(() => d.remove(), 500);
        }

        function updateUI() {
            if (player) {
                document.getElementById('hp-bar').style.width = player.hp + '%';
                document.getElementById('stam-bar').style.width = player.stam + '%';
            }
        }

        // --- 3. FACTORY DE PERSONAJES ---
        function createCharacterMesh(ac, sc, pc) {
            const grp = new THREE.Group();
            grp.add(createCube(0.6, 0.8, 0.3, ac, 0, 1.1, 0));
            const head = new THREE.Group(); head.position.set(0, 1.8, 0);
            head.add(createCube(0.4, 0.4, 0.4, sc, 0, 0, 0));
            head.add(createCube(0.1, 0.05, 0.05, 0x000, 0.1, 0, 0.2));
            head.add(createCube(0.1, 0.05, 0.05, 0x000, -0.1, 0, 0.2));
            grp.add(head);
            const armL = new THREE.Group(); armL.position.set(0.45, 1.3, 0); armL.add(createCube(0.2, 0.6, 0.2, ac, 0, -0.2, 0)); grp.add(armL);
            const armR = new THREE.Group(); armR.position.set(-0.45, 1.3, 0); armR.add(createCube(0.2, 0.6, 0.2, ac, 0, -0.2, 0)); grp.add(armR);
            const legL = new THREE.Group(); legL.position.set(0.2, 0.8, 0); legL.add(createCube(0.25, 0.8, 0.25, pc, 0, -0.4, 0)); grp.add(legL);
            const legR = new THREE.Group(); legR.position.set(-0.2, 0.8, 0); legR.add(createCube(0.25, 0.8, 0.25, pc, 0, -0.4, 0)); grp.add(legR);
            grp.userData.parts = { head, armL, armR, legL, legR };
            return grp;
        }

        function createPlayer() {
            player = { mesh: createCharacterMesh(PALETTE.armor, PALETTE.skin, PALETTE.banditPants), hp: 100, maxHp: 100, stam: 100, attacking: false };
            player.mesh.userData.parts.head.add(createCube(0.45, 0.1, 0.45, PALETTE.hair, 0, 0.25, 0));
            player.mesh.userData.parts.armR.add(createCube(0.08, 1.4, 0.05, 0xffffff, 0, -1.0, 0.15));
            player.parts = player.mesh.userData.parts;
            scene.add(player.mesh);
        }

        function spawnCitizen(x, z) {
            const shirt = PALETTE.civShirts[Math.floor(Math.random() * PALETTE.civShirts.length)];
            const grp = createCharacterMesh(shirt, PALETTE.skin, PALETTE.civPants[0]);
            grp.position.set(x, 0, z); worldGroup.add(grp);
            citizens.push({ mesh: grp, parts: grp.userData.parts, home: { x, z }, state: 'idle', timer: 0, target: new THREE.Vector3(), speed: 2 });
        }

        function spawnGuards(x, z) {
            for (let i = 0; i < 3; i++) {
                let a = Math.random() * 6.28, r = 6;
                let gx = x + Math.cos(a) * r, gz = z + Math.sin(a) * r;
                const grp = createCharacterMesh(PALETTE.soldierArmor, PALETTE.skin, PALETTE.soldierDetail);
                grp.userData.parts.head.add(createCube(0.42, 0.3, 0.42, PALETTE.soldierDetail, 0, 0.1, 0));
                grp.userData.parts.armR.add(createCube(0.05, 2.5, 0.05, 0x5d4037, 0, -0.5, 0.15));
                grp.position.set(gx, 0, gz); worldGroup.add(grp);
                guards.push({ mesh: grp, parts: grp.userData.parts, hp: 50, speed: 3.5, attacking: false, home: { x, z } });
            }
        }

        function createEnemy(x, z, type) {
            const grp = createCharacterMesh(PALETTE.banditLeather, PALETTE.banditSkin, PALETTE.banditPants);
            grp.userData.parts.armR.add(createCube(0.05, 0.6, 0.05, 0x999, 0, -0.6, 0.15));
            grp.position.set(x, 0, z); worldGroup.add(grp);
            enemies.push({ mesh: grp, parts: grp.userData.parts, type: 'bandit', hp: 30, speed: 2.5, attacking: false, cooldown: 0, state: 'idle', timer: 0, target: new THREE.Vector3() });
        }

        function createWerewolf(x, z) {
            const grp = createCharacterMesh(PALETTE.werewolfFur, PALETTE.werewolfSkin, PALETTE.werewolfFur);
            grp.position.set(x, 0, z); worldGroup.add(grp);
            enemies.push({ mesh: grp, parts: grp.userData.parts, type: 'werewolf', hp: 80, speed: 5, attacking: false, cooldown: 0, state: 'idle', timer: 0, target: new THREE.Vector3() });
        }

        function createCrocodile(x, z) {
            const grp = new THREE.Group(); grp.add(createCube(0.8, 0.4, 2.0, PALETTE.crocSkin, 0, 0.3, 0));
            const tail = new THREE.Group(); tail.position.set(0, 0.3, -1); grp.add(tail); tail.add(createCube(0.4, 0.3, 1.5, PALETTE.crocSkin, 0, 0, -0.75));
            const l1 = createCube(0.2, 0.3, 0.2, PALETTE.crocSkin, 0.5, 0.15, 0.8); grp.add(l1);
            const l2 = createCube(0.2, 0.3, 0.2, PALETTE.crocSkin, -0.5, 0.15, 0.8); grp.add(l2);
            const l3 = createCube(0.2, 0.3, 0.2, PALETTE.crocSkin, 0.5, 0.15, -0.8); grp.add(l3);
            const l4 = createCube(0.2, 0.3, 0.2, PALETTE.crocSkin, -0.5, 0.15, -0.8); grp.add(l4);
            grp.position.set(x, 0, z); worldGroup.add(grp);
            enemies.push({ mesh: grp, parts: { tail, l1, l2, l3, l4 }, type: 'crocodile', hp: 120, speed: 1.5, attacking: false, cooldown: 0, state: 'idle', timer: 0, target: new THREE.Vector3() });
        }

        function createPlant(x, z) {
            const grp = new THREE.Group(); grp.add(createCube(0.2, 1.5, 0.2, PALETTE.plantStem, 0, 0.75, 0));
            const head = new THREE.Group(); head.position.set(0, 1.5, 0);
            head.add(createCube(0.8, 0.6, 0.8, PALETTE.plantHead, 0, 0, 0));
            grp.add(head);
            grp.position.set(x, 0, z); worldGroup.add(grp);
            enemies.push({ mesh: grp, parts: { head }, type: 'plant', hp: 150, speed: 0, attacking: false, cooldown: 0 });
        }

        // --- 4. ESTRUCTURAS ---
        function createSpecialBuilding(x, z, type) {
            const grp = new THREE.Group(); grp.position.set(x, 0, z);
            let col = { w: 0x8d6e63, r: 0xd84315 };
            if (type === 'fort') col = { w: 0x757575, r: 0x424242 };
            let w = 4, h = 3; if (type === 'gob') { w = 6; h = 5; }

            const wall = new THREE.Mesh(new THREE.BoxGeometry(w, h, w), new THREE.MeshStandardMaterial({ color: col.w }));
            wall.position.y = h / 2; wall.castShadow = true; grp.add(wall);
            if (type !== 'fort') {
                const roof = new THREE.Mesh(new THREE.ConeGeometry(w * 0.8, 2, 4), new THREE.MeshStandardMaterial({ color: col.r }));
                roof.position.y = h + 1; roof.rotation.y = Math.PI / 4; grp.add(roof);
            }
            worldGroup.add(grp); addCollider(x, z, w);
        }

        function createHouse(x, z) {
            const grp = new THREE.Group(); grp.position.set(x, 0, z);
            const w = new THREE.Mesh(new THREE.BoxGeometry(3, 2.5, 3), new THREE.MeshStandardMaterial({ color: 0x8d6e63 }));
            w.position.y = 1.25; w.castShadow = true; grp.add(w);
            const r = new THREE.Mesh(new THREE.ConeGeometry(2.5, 1.5, 4), new THREE.MeshStandardMaterial({ color: 0xd84315 }));
            r.position.y = 3.25; r.rotation.y = Math.PI / 4; grp.add(r);
            worldGroup.add(grp); addCollider(x, z, 3);
        }

        function createParcel(x, z) {
            const grp = new THREE.Group(); grp.position.set(x, 0.05, z);
            const dirt = new THREE.Mesh(new THREE.BoxGeometry(6, 0.1, 6), new THREE.MeshStandardMaterial({ color: PALETTE.crop }));
            grp.add(dirt);
            for (let i = -2; i <= 2; i += 1.5) for (let j = -2; j <= 2; j += 1.5) {
                const plant = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.6, 0.4), new THREE.MeshStandardMaterial({ color: PALETTE.cropPlant }));
                plant.position.set(i, 0.3, j); grp.add(plant);
            }
            worldGroup.add(grp);
        }

        function spawnVillage(x, z) {
            villageCenters.push({ x: x, z: z });
            createSpecialBuilding(x, z, 'gob');
            createSpecialBuilding(x, z - 10, 'mkt');
            createSpecialBuilding(x + 10, z, 'inn');
            createSpecialBuilding(x - 10, z, 'fort');
            createHouse(x + 8, z + 8); createHouse(x - 8, z + 8); createHouse(x + 8, z - 8);
            createParcel(x + 18, z); createParcel(x - 18, z); createParcel(x, z + 18);
            spawnGuards(x, z);
            for (let i = 0; i < 5; i++) spawnCitizen(x + (Math.random() - 0.5) * 20, z + (Math.random() - 0.5) * 20);
        }

        function createCave(x, z) {
            const grp = new THREE.Group(); grp.position.set(x, 0, z);
            const m = new THREE.Mesh(new THREE.DodecahedronGeometry(2.5, 0), new THREE.MeshStandardMaterial({ color: 0x212121 }));
            m.scale.set(1.5, 0.6, 1.5); m.castShadow = true; grp.add(m);
            worldGroup.add(grp);
            addCollider(x, z, 3);
        }

        function createPortalVisual(x, z) {
            const geo = new THREE.SphereGeometry(2, 16, 16);
            const mat = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.6 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.set(x, 2, z);
            const glow = new THREE.PointLight(0xff0000, 1, 20);
            glow.position.set(x, 2, z);
            worldGroup.add(mesh);
            worldGroup.add(glow);
        }

        // --- 5. GENERACIÓN DE MUNDO ---
        function placeProp(x, z, h, mt, ml, idx, isPine) {
            const dum = new THREE.Object3D();
            dum.position.set(x, 1.5 + h, z); dum.rotation.y = Math.random() * Math.PI; dum.scale.set(1, 1 + Math.random() * 0.5, 1);
            dum.updateMatrix(); mt.setMatrixAt(idx, dum.matrix);
            dum.position.y = (isPine ? 3 : 2.5) + h + dum.scale.y; dum.scale.set(1, 1, 1);
            dum.updateMatrix(); ml.setMatrixAt(idx, dum.matrix);
            addCollider(x, z, 0.6);
        }

        function generateTerrain(type) {
            const size = SCENARIO_SIZE / TILE_SIZE;
            const offset = SCENARIO_SIZE / 2;

            let c = { grass: 0, dirt: 0, water: 0, snow: 0, ice: 0, swampG: 0, swampW: 0, tree: 0, pine: 0, dead: 0, rock: 0, weed: 0, flower: 0 };
            let grid = [];

            for (let x = 0; x < size; x++) {
                for (let z = 0; z < size; z++) {
                    let wx = x * 2 - offset; let wz = z * 2 - offset;
                    let cell = { x: wx, z: wz, type: 'ground', prop: null };

                    let isEdge = (Math.abs(wx) > SCENARIO_SIZE / 2 - 4 || Math.abs(wz) > SCENARIO_SIZE / 2 - 4);
                    if (isEdge) {
                        let nearPortal = false;
                        for (let p of activePortals) if (Math.hypot(wx - p.x, wz - p.z) < 8) nearPortal = true;
                        if (!nearPortal) addCollider(wx, wz, 4);
                    }

                    let noise = Math.sin(x / 10) * Math.cos(z / 10);
                    if (type === 'swamp' && noise > 0.5) { cell.type = 'swampWater'; c.swampW++; }
                    else if (type === 'snow' && noise > 0.8) { cell.type = 'ice'; c.ice++; }
                    else if (type === 'desert' && noise > 0.85) { cell.type = 'water'; c.water++; }
                    else {
                        if (type === 'snow') c.snow++; else if (type === 'swamp') c.swampG++; else c.grass++;
                        if (!isEdge && Math.random() > 0.85) {
                            let r = Math.random();
                            if (type === 'snow') {
                                if (r > 0.96) { cell.prop = 'pine'; c.pine++; } else if (r > 0.94) { cell.prop = 'rock'; c.rock++; }
                            } else if (type === 'swamp') {
                                if (r > 0.97) { cell.prop = 'dead'; c.dead++; } else if (r > 0.6) { cell.prop = 'weed'; c.weed++; }
                            } else if (type === 'desert') {
                                if (r > 0.98) { cell.prop = 'rock'; c.rock++; }
                            } else {
                                if (r > 0.95) { cell.prop = 'tree'; c.tree++; } else if (r > 0.93) { cell.prop = 'rock'; c.rock++; }
                                else if (r > 0.85) { cell.prop = 'flower'; c.flower++; } else if (r > 0.50) { cell.prop = 'weed'; c.weed++; }
                            }
                        }
                    }
                    grid.push(cell);
                }
            }

            const gb = new THREE.BoxGeometry(2, 0.2, 2);
            const mGrass = new THREE.InstancedMesh(gb, new THREE.MeshStandardMaterial({ color: PALETTE.grass }), c.grass);
            const mDirt = new THREE.InstancedMesh(gb, new THREE.MeshStandardMaterial({ color: PALETTE.dirt }), c.dirt);
            const mWater = new THREE.InstancedMesh(gb, new THREE.MeshStandardMaterial({ color: PALETTE.water, transparent: true, opacity: 0.7 }), c.water);
            const mSnow = new THREE.InstancedMesh(gb, new THREE.MeshStandardMaterial({ color: PALETTE.snow }), c.snow);
            const mIce = new THREE.InstancedMesh(gb, new THREE.MeshStandardMaterial({ color: PALETTE.ice, transparent: true, opacity: 0.9 }), c.ice);
            const mSwampG = new THREE.InstancedMesh(gb, new THREE.MeshStandardMaterial({ color: PALETTE.swampGrass }), c.swampG);
            const mSwampW = new THREE.InstancedMesh(gb, new THREE.MeshStandardMaterial({ color: PALETTE.swampWater, transparent: true, opacity: 0.8 }), c.swampW);
            [mGrass, mSnow, mSwampG].forEach(m => m.receiveShadow = true);

            const mTreeT = new THREE.InstancedMesh(new THREE.BoxGeometry(0.5, 2, 0.5), new THREE.MeshStandardMaterial({ color: PALETTE.wood }), c.tree);
            const mTreeL = new THREE.InstancedMesh(new THREE.BoxGeometry(2.2, 2.2, 2.2), new THREE.MeshStandardMaterial({ color: PALETTE.leaves }), c.tree);
            const mPineT = new THREE.InstancedMesh(new THREE.BoxGeometry(0.5, 2, 0.5), new THREE.MeshStandardMaterial({ color: PALETTE.pineWood }), c.pine);
            const mPineL = new THREE.InstancedMesh(new THREE.ConeGeometry(1.5, 4, 4), new THREE.MeshStandardMaterial({ color: PALETTE.pineLeaves }), c.pine);
            const mDead = new THREE.InstancedMesh(new THREE.BoxGeometry(0.4, 2.5, 0.4), new THREE.MeshStandardMaterial({ color: PALETTE.deadWood }), c.dead);
            const mRock = new THREE.InstancedMesh(new THREE.DodecahedronGeometry(0.7, 0), new THREE.MeshStandardMaterial({ color: PALETTE.rock }), c.rock);
            const mFlower = new THREE.InstancedMesh(new THREE.BoxGeometry(0.2, 0.3, 0.2), new THREE.MeshStandardMaterial({ color: 0xffffff }), c.flower);
            const mWeed = new THREE.InstancedMesh(new THREE.BoxGeometry(0.1, 0.5, 0.1), new THREE.MeshStandardMaterial({ color: PALETTE.weed }), c.weed * 3);
            [mTreeT, mTreeL, mPineT, mPineL, mDead, mRock].forEach(m => { m.receiveShadow = true; m.castShadow = true; });

            let idx = { g: 0, w: 0, s: 0, i: 0, sg: 0, sw: 0, t: 0, p: 0, d: 0, r: 0, f: 0, wd: 0 };
            const dum = new THREE.Object3D();
            const col = new THREE.Color();

            grid.forEach(cell => {
                dum.rotation.set(0, 0, 0); dum.scale.set(1, 1, 1);
                if (cell.type === 'path') {
                    dum.position.set(cell.x, -0.1, cell.z); dum.updateMatrix(); mDirt.setMatrixAt(idx.d++, dum.matrix);
                } else if (cell.type.includes('water') || cell.type === 'ice') {
                    dum.position.set(cell.x, -0.3, cell.z); dum.updateMatrix();
                    if (cell.type === 'ice') mIce.setMatrixAt(idx.i++, dum.matrix);
                    else if (cell.type === 'swampWater') mSwampW.setMatrixAt(idx.sw++, dum.matrix);
                    else mWater.setMatrixAt(idx.w++, dum.matrix);
                    addCollider(cell.x, cell.z, 2);
                } else {
                    let h = Math.random() * 0.15;
                    dum.position.set(cell.x, h, cell.z); dum.updateMatrix();
                    if (type === 'snow') mSnow.setMatrixAt(idx.s++, dum.matrix);
                    else if (type === 'swamp') mSwampG.setMatrixAt(idx.sg++, dum.matrix);
                    else {
                        mGrass.setMatrixAt(idx.g, dum.matrix);
                        if (type === 'desert') mGrass.setColorAt(idx.g++, col.setHex(PALETTE.sand));
                        else if (type === 'jungle') mGrass.setColorAt(idx.g++, col.setHex(PALETTE.jungleGrass));
                        else idx.g++;
                    }

                    if (cell.prop) {
                        let inVillage = villageCenters.some(v => Math.hypot(cell.x - v.x, cell.z - v.z) < 18);
                        if (!inVillage) {
                            if (cell.prop === 'tree') {
                                placeProp(cell.x, cell.z, h, mTreeT, mTreeL, idx.t++, false);
                            } else if (cell.prop === 'pine') {
                                placeProp(cell.x, cell.z, h, mPineT, mPineL, idx.p++, true);
                            } else if (cell.prop === 'dead') {
                                dum.position.set(cell.x, 1.25 + h, cell.z); dum.rotation.set(Math.random() * 0.2, Math.random() * 3, Math.random() * 0.2);
                                dum.updateMatrix(); mDead.setMatrixAt(idx.d++, dum.matrix); addCollider(cell.x, cell.z, 0.4);
                            } else if (cell.prop === 'rock') {
                                dum.position.set(cell.x, 0.5 + h, cell.z); dum.rotation.set(Math.random(), Math.random(), Math.random());
                                dum.scale.setScalar(0.6 + Math.random()); dum.updateMatrix(); mRock.setMatrixAt(idx.r, dum.matrix);
                                if (type === 'snow') mRock.setColorAt(idx.r - 1, col.setHex(0xeeeeee)); else mRock.setColorAt(idx.r - 1, col.setHex(PALETTE.rock));
                                addCollider(cell.x, cell.z, 0.8);
                            } else if (cell.prop === 'flower') {
                                dum.position.set(cell.x + (Math.random() - .5), 0.25 + h, cell.z + (Math.random() - .5));
                                dum.rotation.set(0, Math.random(), 0); dum.scale.set(1, 1, 1);
                                dum.updateMatrix(); mFlower.setMatrixAt(idx.f, dum.matrix);
                                mFlower.setColorAt(idx.f++, col.setHex(PALETTE.flowers[Math.floor(Math.random() * PALETTE.flowers.length)]));
                            } else if (cell.prop === 'weed') {
                                for (let k = 0; k < 3; k++) {
                                    dum.position.set(cell.x + (Math.random() - .5), 0.3 + h, cell.z + (Math.random() - .5));
                                    dum.rotation.y = Math.random() * 3; dum.scale.y = 0.5 + Math.random();
                                    dum.updateMatrix(); mWeed.setMatrixAt(idx.wd, dum.matrix);
                                    if (type === 'swamp') mWeed.setColorAt(idx.wd++, col.setHex(0x2e3b20)); else idx.wd++;
                                }
                            }
                        }
                    }
                }
            });

            worldGroup.add(mGrass, mDirt, mWater, mSnow, mIce, mSwampG, mSwampW);
            worldGroup.add(mTreeT, mTreeL, mPineT, mPineL, mDead, mRock, mFlower, mWeed);
        }

        // --- 6. INICIALIZACION DE BIOMA Y LOGICA PRINCIPAL ---

        function spawnRandomEnemies(n) {
            for (let i = 0; i < n; i++) {
                let x = (Math.random() - 0.5) * 150, z = (Math.random() - 0.5) * 150;
                if (Math.abs(x) > 20 || Math.abs(z) > 20) createEnemy(x, z, 'bandit');
            }
        }

        function spawnStaticSwampPlants() { swampCaves.forEach(c => createPlant(c.x + 5, c.z)); }

        function loadBiome(bx, by) {
            worldGroup.clear();
            solidColliders = [];
            enemies = [];
            guards = [];
            citizens = [];
            particles = [];
            swampCaves = [];
            villageCenters = [];
            activePortals = [];

            let key = bx + "," + by;
            let data = BIOME_DATA[key];
            if (!data) data = { name: "Tierras Salvajes", type: 'plains', color: 0x8bc34a, sky: 0x87ceeb };

            currentBiomeCoords = { x: bx, y: by };
            scene.background = new THREE.Color(data.sky);
            scene.fog.color.setHex(data.sky);

            const title = document.getElementById('biome-label');
            title.innerText = data.name;
            title.style.opacity = 1;
            setTimeout(() => title.style.opacity = 0, 3000);

            const limit = SCENARIO_SIZE / 2 - 5;
            if (bx === 0 && by === 0) {
                activePortals.push({ x: 0, z: -limit, target: { x: 0, y: -1 }, name: "Norte" });
                activePortals.push({ x: 0, z: limit, target: { x: 0, y: 1 }, name: "Sur" });
                activePortals.push({ x: limit, z: 0, target: { x: 1, y: 0 }, name: "Este" });
                activePortals.push({ x: -limit, z: 0, target: { x: -1, y: 0 }, name: "Oeste" });
            } else {
                if (by === -1) activePortals.push({ x: 0, z: limit, target: { x: 0, y: 0 }, name: "Regreso" });
                if (by === 1) activePortals.push({ x: 0, z: -limit, target: { x: 0, y: 0 }, name: "Regreso" });
                if (bx === 1) activePortals.push({ x: -limit, z: 0, target: { x: 0, y: 0 }, name: "Regreso" });
                if (bx === -1) activePortals.push({ x: limit, z: 0, target: { x: 0, y: 0 }, name: "Regreso" });
            }

            generateTerrain(data.type);

            let numVillages = 2 + Math.floor(Math.random() * 2);
            for (let i = 0; i < numVillages; i++) {
                let safe = false;
                let vx, vz;
                let attempts = 0;
                while (!safe && attempts < 100) {
                    vx = (Math.random() - 0.5) * (SCENARIO_SIZE * 0.6);
                    vz = (Math.random() - 0.5) * (SCENARIO_SIZE * 0.6);
                    safe = true;
                    if (Math.hypot(vx, vz) < 40) safe = false;
                    for (let v of villageCenters) if (Math.hypot(vx - v.x, vz - v.z) < 60) safe = false;
                    attempts++;
                }
                if (safe) {
                    spawnVillage(vx, vz);
                }
            }

            if (data.type === 'swamp') {
                swampCaves.push({ x: 40, z: 40, cooldown: 0 }, { x: -40, z: -30, cooldown: 0 }, { x: 50, z: -50, cooldown: 0 });
                swampCaves.forEach(c => createCave(c.x, c.z));
                spawnStaticSwampPlants();
            } else {
                spawnRandomEnemies(20);
            }

            activePortals.forEach(p => createPortalVisual(p.x, p.z));
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            scene.fog = new THREE.Fog(0x87ceeb, 20, 90);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 45, 35);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            const container = document.getElementById('game-container');
            while (container.firstChild) container.removeChild(container.firstChild);
            container.appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const sun = new THREE.DirectionalLight(0xffeebb, 0.9);
            sun.position.set(50, 100, 50);
            sun.castShadow = true;
            sun.shadow.mapSize.width = 2048; sun.shadow.mapSize.height = 2048;
            sun.shadow.camera.left = -60; sun.shadow.camera.right = 60;
            sun.shadow.camera.top = 60; sun.shadow.camera.bottom = -60;
            scene.add(sun);

            mousePlane = new THREE.Mesh(new THREE.PlaneGeometry(1000, 1000), new THREE.MeshBasicMaterial({ visible: false }));
            mousePlane.rotation.x = -Math.PI / 2;
            scene.add(mousePlane);

            worldGroup = new THREE.Group();
            scene.add(worldGroup);

            createPlayer();
            clock = new THREE.Clock();

            window.addEventListener('resize', onResize);
            window.addEventListener('keydown', e => handleKey(e, 1));
            window.addEventListener('keyup', e => handleKey(e, 0));
            window.addEventListener('mousemove', e => {
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            });
            window.addEventListener('mousedown', e => {
                if (player.hp > 0) {
                    if (e.button === 0) attack('sword');
                    if (e.button === 2) attack('igni');
                }
            });
            window.addEventListener('contextmenu', e => e.preventDefault());
        }

        // --- LOGICA Y UPDATES ---
        function checkCaveSpawns(dt) {
            const spawnDist = 25;
            let wChance = enemies.some(e => e.type === 'werewolf') ? 0.001 : 0.02;
            let cChance = enemies.some(e => e.type === 'crocodile') ? 0.001 : 0.02;
            swampCaves.forEach(c => {
                if (c.cooldown > 0) { c.cooldown -= dt; return; }
                if (player.mesh.position.distanceTo(new THREE.Vector3(c.x, 0, c.z)) < spawnDist) {
                    if (Math.random() < wChance) createWerewolf(c.x + (Math.random() - .5) * 5, c.z + (Math.random() - .5) * 5);
                    if (Math.random() < cChance) createCrocodile(c.x + (Math.random() - .5) * 5, c.z + (Math.random() - .5) * 5);
                    c.cooldown = 15;
                }
            });
        }

        function checkPortals() {
            const limit = SCENARIO_SIZE / 2 - 5;
            const p = player.mesh.position;
            for (let portal of activePortals) {
                if (Math.hypot(p.x - portal.x, p.z - portal.z) < 4) {
                    let nextX = currentBiomeCoords.x + portal.target.x;
                    let nextY = currentBiomeCoords.y + portal.target.y;
                    loadBiome(nextX, nextY);
                    if (portal.target.y === -1) player.mesh.position.z = limit - 8;
                    else if (portal.target.y === 1) player.mesh.position.z = -limit + 8;
                    else if (portal.target.x === 1) player.mesh.position.x = -limit + 8;
                    else if (portal.target.x === -1) player.mesh.position.x = limit - 8;
                    else player.mesh.position.set(0, 0, 0);
                    return;
                }
            }
        }

        function checkCol(dx, dz) {
            const np = player.mesh.position.clone().add(new THREE.Vector3(dx, 0, dz));
            const box = new THREE.Box3().setFromCenterAndSize(new THREE.Vector3(np.x, 1, np.z), new THREE.Vector3(0.5, 5, 0.5));
            for (let c of solidColliders) if (box.intersectsBox(c)) return true;
            return false;
        }

        function animateChar(c, move, t) {
            if (!c.parts) return;
            if (move) {
                if (c.parts.legL) c.parts.legL.rotation.x = Math.sin(t * 15) * 0.8;
                if (c.parts.legR) c.parts.legR.rotation.x = Math.sin(t * 15 + Math.PI) * 0.8;
                if (!c.attacking) { if (c.parts.armL) c.parts.armL.rotation.x = Math.sin(t * 15 + Math.PI) * 0.8; if (c.parts.armR) c.parts.armR.rotation.x = Math.sin(t * 15) * 0.8; }
            } else {
                if (c.parts.legL) c.parts.legL.rotation.x = 0; if (c.parts.legR) c.parts.legR.rotation.x = 0;
                if (!c.attacking) { if (c.parts.armL) c.parts.armL.rotation.x = 0; if (c.parts.armR && c !== player) c.parts.armR.rotation.x = 0; }
            }
        }

        function animateMonster(e, moving, t) {
            if (e.type === 'crocodile') {
                if (moving) {
                    e.parts.l1.rotation.x = Math.sin(t * 10) * 0.5; e.parts.l2.rotation.x = Math.sin(t * 10 + Math.PI) * 0.5;
                    e.parts.l3.rotation.x = Math.sin(t * 10 + Math.PI) * 0.5; e.parts.l4.rotation.x = Math.sin(t * 10) * 0.5;
                    e.parts.tail.rotation.y = Math.sin(t * 10) * 0.3;
                }
            } else if (e.type === 'plant') {
                e.parts.head.position.y = 1.5 + Math.sin(t * 2) * 0.1;
                if (e.attacking) e.parts.head.rotation.x = Math.sin(t * 20) * 0.5;
            }
        }

        function updateEntities(dt, t) {
            citizens.forEach(c => {
                c.timer -= dt; let moving = false;
                if (c.timer <= 0) {
                    if (c.state === 'idle') {
                        let a = Math.random() * 6.28, d = Math.random() * 8;
                        c.target.set(c.home.x + Math.cos(a) * d, 0, c.home.z + Math.sin(a) * d);
                        c.state = 'walk'; c.timer = 3;
                    } else { c.state = 'idle'; c.timer = 3; }
                }
                if (c.state === 'walk' && c.mesh.position.distanceTo(c.target) > 0.5) {
                    c.mesh.lookAt(c.target.x, 0, c.target.z); c.mesh.translateZ(c.speed * dt); moving = true;
                }
                animateChar(c, moving, t);
            });
            [enemies, guards].flat().forEach(e => {
                if (e.hp > 0) {
                    let move = false;
                    if (e.type && e.type !== 'plant') {
                        const d = player.mesh.position.distanceTo(e.mesh.position);
                        if (d < 25 && d > 1.5) {
                            e.mesh.lookAt(player.mesh.position); e.mesh.translateZ(e.speed * dt); move = true;
                            if (d < 2 && !e.attacking) { e.attacking = true; setTimeout(() => { damageEntity(player, 5); e.attacking = false; updateUI(); if (player.hp <= 0) handleDeath(); }, 500); }
                        }
                    }
                    if (e.type === 'crocodile' || e.type === 'plant') animateMonster(e, move, t);
                    else animateChar(e, move, t);
                }
            });
        }

        function damageEntity(e, dmg) {
            e.hp -= dmg; createFloatText(e.mesh.position, "-" + dmg);
            e.mesh.traverse(o => { if (o.material && o.material.emissive) { o.material.emissive.setHex(0xff0000); setTimeout(() => o.material.emissive.setHex(0), 100); } });
            if (e.hp <= 0) { worldGroup.remove(e.mesh); let idx = enemies.indexOf(e); if (idx > -1) enemies.splice(idx, 1); updateQuest(); }
        }

        function handleDeath() { document.getElementById('death-screen').style.display = 'flex'; isRunning = false; }

        function attack(type) {
            if (player.hp <= 0) return;
            if (type === 'sword' && player.stam >= 15 && !player.attacking) {
                player.stam -= 15; player.attacking = true; updateUI();
                const arm = player.parts.armR; let p = 0;
                const iv = setInterval(() => { p += 0.2; arm.rotation.x = -Math.PI / 2 * Math.sin(p * Math.PI); if (p >= 1) { clearInterval(iv); arm.rotation.x = 0; player.attacking = false; } }, 16);
                createFX(player.mesh.position, 0xffffff, 'slash');
                checkHit(5, 2.0, 25);
            }
            if (type === 'igni' && player.stam >= 30 && !player.attacking) {
                player.stam -= 30; player.attacking = true; updateUI();
                player.parts.armL.rotation.x = -3; setTimeout(() => { player.parts.armL.rotation.x = 0; player.attacking = false }, 500);
                createFX(player.mesh.position, 0xff6d00, 'exp');
                checkHit(8, 6.0, 40);
            }
        }
        function checkHit(r, a, dmg) {
            const pDir = new THREE.Vector3(); player.mesh.getWorldDirection(pDir);
            enemies.forEach((e, idx) => {
                const dir = new THREE.Vector3().subVectors(e.mesh.position, player.mesh.position);
                if (dir.length() < r && pDir.angleTo(dir) < a) {
                    damageEntity(e, dmg);
                }
            });
        }
        function createFX(pos, col, type) {
            const geo = type === 'slash' ? new THREE.PlaneGeometry(5, 5) : new THREE.SphereGeometry(3, 8, 8);
            const mat = new THREE.MeshBasicMaterial({ color: col, transparent: true, opacity: 0.8, side: THREE.DoubleSide });
            const m = new THREE.Mesh(geo, mat); m.position.copy(pos).add(new THREE.Vector3(0, 1, 0));
            if (type === 'slash') { m.rotation.x = -Math.PI / 2; m.rotation.z = player.mesh.rotation.y; }
            scene.add(m); particles.push({ mesh: m, life: 0.3, type });
        }

        function updateParticles(dt) {
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i]; p.life -= dt;
                if (p.type === 'exp') p.mesh.scale.multiplyScalar(1.1);
                if (p.life <= 0) { scene.remove(p.mesh); particles.splice(i, 1); }
            }
        }

        function updateQuest() {
            const questText = document.getElementById('quest-text');
            if (questText) {
                questText.innerHTML = enemies.length > 0 ? `AMENAZAS: ${enemies.length}` : "¡VICTORIA!";
            }
        }
        function drawMinimap() {
            if (!mapCtx) return;
            mapCtx.fillStyle = '#1a1a1a'; mapCtx.fillRect(0, 0, 150, 150);
            const SCALE = 0.5; const CX = 75; const CY = 75; const pPos = player.mesh.position;
            villageCenters.forEach(v => {
                let x = (v.x - pPos.x) * SCALE + CX; let y = (v.z - pPos.z) * SCALE + CY;
                if (x > 0 && x < 150 && y > 0 && y < 150) { mapCtx.fillStyle = '#ffd54f'; mapCtx.fillRect(x - 4, y - 4, 8, 8); }
            });
            mapCtx.fillStyle = '#ff1744';
            enemies.forEach(e => {
                let x = (e.mesh.position.x - pPos.x) * SCALE + CX; let y = (e.mesh.position.z - pPos.z) * SCALE + CY;
                if (x > 0 && x < 150 && y > 0 && y < 150) mapCtx.fillRect(x - 1.5, y - 1.5, 3, 3);
            });
            mapCtx.fillStyle = '#4fc3f7';
            for (let g of guards) {
                let gx = (g.mesh.position.x - pPos.x) * SCALE + CX; let gz = (g.mesh.position.z - pPos.z) * SCALE + CY;
                if (gx > 0 && gx < 150 && gz > 0 && gz < 150) mapCtx.fillRect(gx - 1.5, gz - 1.5, 3, 3);
            }
            mapCtx.fillStyle = '#00e676'; mapCtx.beginPath(); mapCtx.arc(CX, CY, 3, 0, Math.PI * 2); mapCtx.fill();
        }

        function animate() {
            if (!isRunning) return;
            requestAnimationFrame(animate);
            const dt = Math.min(clock.getDelta(), 0.1);
            const time = clock.getElapsedTime();

            checkPortals();
            checkCaveSpawns(dt);

            let dx = 0, dz = 0;
            if (keys.w) dz -= 1; if (keys.s) dz += 1; if (keys.a) dx -= 1; if (keys.d) dx += 1;
            let moving = (dx !== 0 || dz !== 0);
            if (moving) {
                if (dx !== 0 && dz !== 0) { dx *= 0.707; dz *= 0.707; }
                const s = 10 * dt;
                if (!checkCol(dx * s, 0)) player.mesh.position.x += dx * s;
                if (!checkCol(0, dz * s)) player.mesh.position.z += dz * s;
            }

            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObject(mousePlane);
            if (hits.length > 0) player.mesh.lookAt(hits[0].point.x, player.mesh.position.y, hits[0].point.z);

            camera.position.x = player.mesh.position.x;
            camera.position.z = player.mesh.position.z + 30;
            camera.lookAt(player.mesh.position);

            animateChar(player, moving, time);
            updateEntities(dt, time);
            updateParticles(dt);
            drawMinimap();

            if (player.stam < 100) { player.stam += 10 * dt; updateUI(); }
            renderer.render(scene, camera);
        }
    </script>
</body>

</html>